import os
import subprocess
import tempfile
import shutil
import json

def handler(request, response):
    print("Python Vercel function 'convert' started.")
    
    try:
        if request.method != 'POST':
            response.status(405).json({'error': 'Method Not Allowed'})
            return

        body = request.json()
        python_code = body.get('pythonCode')

        if not python_code:
            response.status(400).json({'error': 'Python code is required'})
            return

        with tempfile.TemporaryDirectory(dir='/tmp') as tmpdir:
            script_name = "script.py"
            script_path = os.path.join(tmpdir, script_name)
            with open(script_path, 'w') as f:
                f.write(python_code)

            output_dir = os.path.join(tmpdir, 'dist')
            work_dir = os.path.join(tmpdir, 'build')
            spec_dir = os.path.join(tmpdir, 'spec')

            os.makedirs(output_dir, exist_ok=True)
            os.makedirs(work_dir, exist_ok=True)
            os.makedirs(spec_dir, exist_ok=True)

            print(f"Attempting to run PyInstaller for script: {script_path}")
            command = [
                'pyinstaller',
                '--onefile',
                '--distpath', output_dir,
                '--workpath', work_dir,
                '--specpath', spec_dir,
                script_path
            ]
            
            print(f"PyInstaller command: {' '.join(command)}")
            
            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False
            )
            
            print("PyInstaller stdout:", process.stdout)
            print("PyInstaller stderr:", process.stderr)

            if process.returncode != 0:
                print(f"PyInstaller failed with exit code {process.returncode}")
                response.status(500).json({'error': f'Компиляция PyInstaller не удалась. Stderr: {process.stderr}'})
                return

            generated_exe_name = None
            for filename in os.listdir(output_dir):
                if filename.endswith('.exe'):
                    generated_exe_name = filename
                    break
            
            if not generated_exe_name:
                print("No .exe file generated by PyInstaller.")
                response.status(500).json({'error': 'PyInstaller не смог сгенерировать исполняемый файл. Проверьте логи PyInstaller на наличие ошибок.'})
                return

            exe_file_path = os.path.join(output_dir, generated_exe_name)
            
            # Читаем сгенерированный .exe файл
            with open(exe_file_path, 'rb') as f:
                exe_content = f.read()

            # Устанавливаем заголовки для скачивания файла
            response.headers['Content-Type'] = 'application/octet-stream'
            response.headers['Content-Disposition'] = f'attachment; filename="{generated_exe_name}"'
            response.status(200).send(exe_content) # Отправляем бинарное содержимое
            print(f"Successfully sent {generated_exe_name} as response.")
            return

    except Exception as e:
        print(f"An unexpected server error occurred: {e}")
        response.status(500).json({'error': f'Внутренняя ошибка сервера: {str(e)}'})